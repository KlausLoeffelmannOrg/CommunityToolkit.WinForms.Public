using Chatty.ViewModels;
using Chatty.Views;
using CommunityToolkit.WinForms.ComponentModel;
using CommunityToolkit.WinForms.Extensions;

namespace Chatty;

public partial class FrmMain : Form
{
    private const string Key_MainView_Bounds = nameof(Key_MainView_Bounds);
    private const string Key_Options = nameof(Key_Options);

    private static readonly string ApiKeyEnvironmentVarLookup = "AI:OpenAI:ApiKey";
    private readonly IUserSettingsService _settingsService;

    private OptionsViewModel? _options;
    private PersonalityViewModel _personalities = null!;
    private bool _hadAutogeneratedTitle;

    public FrmMain()
    {
        InitializeComponent();

        _settingsService = WinFormsUserSettingsService.CreateAndLoad();

        // Wiring the delegate which provides the Open AI ApiKey when we need it:
        _skCommunicator.ApiKeyGetter =
            () => Environment.GetEnvironmentVariable(ApiKeyEnvironmentVarLookup)
                ?? throw new NullReferenceException("Could not retrieve Open AI ApiKey.");

        // We are wiring up the second one exactly like that.
        _skMetaDataProcessor.ApiKeyGetter = _skCommunicator.ApiKeyGetter;

        // The system-prompt for getting the Meta-Info is kind of an easy one.
        _skMetaDataProcessor.SystemPrompt = "You are an assistant in an LLM Chat-Bot client software. " +
            "You're main task is to provide a good title for an ongoing conversation " +
            "with maximal 40 characters based on the initial discussions." +
            "If the provided conversation string would result in a result too generic or meaningless, " +
            "please return '***TOO GENERIC***'.";

        // Handle changing the personalities:
        _tscPersonalities.SelectedIndexChanged += (s, e) =>
        {
            // Lookup the selected personality:
            PersonalityItemViewModel selectedPersonality = _tscPersonalities.SelectedItem as PersonalityItemViewModel
                ?? throw new NullReferenceException("Personality disorder exception!");

            _skCommunicator.SystemPrompt = selectedPersonality.SystemPrompt;
        };
    }

    protected override void OnLoad(EventArgs e)
    {
        base.OnLoad(e);

        _conversationView.ConversationTitle = $"New chat on {DateTime.Now:dddd, MMM dd yyyy}";

        Rectangle bounds = _settingsService.GetInstance(
            Key_MainView_Bounds,
            this.CenterOnScreen(
                horizontalFillGrade: 80,
                verticalFillGrade: 80));

        Bounds = bounds;

        _options = _settingsService.GetInstance(
            key: Key_Options,
            defaultValue: new OptionsViewModel());

        _personalities = PersonalityViewModel
            .GetPersonalitiesOrDefault(_options.BasePath);

        RebuildPersonalitiesDropDown();
        UpdateTreeView();
    }

    protected override void OnFormClosed(FormClosedEventArgs e)
    {
        base.OnFormClosed(e);

        _settingsService.SetInstance(Key_MainView_Bounds, this.GetRestorableBounds());
        _settingsService.SetInstance(Key_Options, _options);
        _settingsService.Save();
    }

    private void ConversationView_ConversationItemAdded(object sender, CommunityToolkit.WinForms.Controls.Blazor.ConversationItemAddedEventArgs e)
    {
        // Let's test, if we have found an automated title yet:
        if (!_hadAutogeneratedTitle)
        {
            return;
        }

        // Let's create a filename from the title and make sure, it doesn't have any invalid characters:
        string title = _conversationView.ConversationTitle!;
        string fileName = string.Join("_", title.Split(Path.GetInvalidFileNameChars()));

        // Now, we can write the JSon of the conversation into the file:
        string json = _conversationView.ToJson();
        string path = Path.Combine(_options!.BasePath, $"{fileName}.cjson");

        // And write it to the file:
        File.WriteAllText(path, json);

        // Let's update the TreeView
        UpdateTreeView();
    }

    private async Task PromptControl_AsyncSendPrompt(object sender, EventArgs e)
    {
        string textToSend = _promptControl.Text;
        _promptControl.Clear();

        // Make sure we can await it in the context of awaiting other tasks,
        // even when there is nothing to do.
        Task<(bool, string?)> updateTitleTask = Task.FromResult<(bool, string?)>((false, null));

        // Do we have yet an autogenerated title based on the ongoing conversation?
        if (!_hadAutogeneratedTitle)
        {
            // No. So, this is the task to get one:
            updateTitleTask = TryUpdateTitleFromConversationAsync(textToSend)
                .ContinueWith(previousTask =>
                {
                    // And once we got it, we can update the title.
                    if (!previousTask.IsCompletedSuccessfully)
                    {
                        return (false, null);
                    }

                    if (previousTask.Result.hasAutoGeneratedTitle)
                    {
                        // Setting this in the conversation view will update the UI. 
                        _conversationView.ConversationTitle = previousTask.Result.autoGeneratedTitle;
                        _hadAutogeneratedTitle = true;
                    }

                    return previousTask.Result;
                });
        }

        // First, we add our original question to the conversation view:
        _conversationView.AddConversationItem(textToSend, isResponse: false);

        // And then, we let the _skCommunicator "pump" it's partial results from the
        // async stream to the conversation view. When the answer is complete, we will be
        // getting a respective event a la WinForms. And that's where we can write the
        // conversation items on disc.
        IAsyncEnumerable<string> responses = _conversationView.UpdateCurrentResponseAsync(
            asyncEnumerable: _skCommunicator.RequestPromptResponseStreamAsync(textToSend, true));

        Task responsePumpingTask = ResponsePumpingAsync(responses);

        // Let's wait for both task to complete (Auto title generation and response pumping).
        await Task.WhenAll(updateTitleTask, responsePumpingTask);

        // That's the task which gets the title from the conversation.
        async Task<(bool hasAutoGeneratedTitle, string? autoGeneratedTitle)> TryUpdateTitleFromConversationAsync(string text)
        {
            var title = await _skMetaDataProcessor.RequestTextPromptResponseAsync(text, false);

            if (title == "***TOO GENERIC***")
            {
                return (false, null);
            }

            return (true, title);
        }

        // And this is actual pumping, which here does nothing.
        // This could be modified, for example to write logs or construct something.
        async Task ResponsePumpingAsync(IAsyncEnumerable<string> responses)
        {
            await foreach (string? response in responses)
            {
                if (response is null)
                {
                    continue;
                }
            }
        }
    }

    private async void PromptControl_NewPromptSuggestionRequest(object sender, EventArgs e)
    {
        // string funnyRandomPrompt = FunnyPromptsProvider.GetRandomPrompt();
        // _promptControl.Text = funnyRandomPrompt;

        // We use a "side-affect" of InvokeAsync to schedule this,
        // so that the text is set _before_ we select it.
        await _promptControl.InvokeAsync(() => _promptControl.SelectAll());
    }

    private void BtnStartNewChat_Click(object sender, EventArgs e)
    {
        _conversationView.ClearHistory();
        _conversationView.ConversationTitle = $"New chat on {DateTime.Now:dddd, MMM dd yyyy}";
        _skCommunicator?.ChatHistory?.Clear();
        _hadAutogeneratedTitle = false;
    }

    private void Personalities_Click(object sender, EventArgs e)
    {
        // Let's open the personality editor:
        FrmManagePersonalities editor = new(_personalities);
        if (editor.ShowDialog(this) == DialogResult.OK)
        {
            _personalities = editor.Personalities;
            RebuildPersonalitiesDropDown();
        }
    }

    private void RebuildPersonalitiesDropDown()
    {
        // Let's remember the currently selected ID:
        Guid selectedId = _tscPersonalities.SelectedItem is PersonalityItemViewModel selectedPersonality
            ? selectedPersonality.Id : Guid.Empty;

        _tscPersonalities.Items.Clear();
        _tscPersonalities.Items.AddRange([.. _personalities.Personalities]);

        // If the remembered Guid is Empty, let's select the first one:
        if (selectedId == Guid.Empty && _tscPersonalities.Items.Count > 0)
        {
            _tscPersonalities.SelectedIndex = 0;

            return;
        }

        // And select the one we had before:
        _tscPersonalities.SelectedItem = _tscPersonalities.Items
            .OfType<PersonalityItemViewModel>()
            .FirstOrDefault(item => item.Id == selectedId);
    }
}
